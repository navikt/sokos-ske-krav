package no.nav.sokos.ske.krav.util

import kotlin.reflect.full.memberProperties

import com.zaxxer.hikari.HikariDataSource
import kotliquery.LoanPattern
import kotliquery.Row
import kotliquery.Session
import kotliquery.TransactionalSession
import kotliquery.sessionOf

object DBUtils {
    inline fun <reified T : Any> Row.optionalOrNull(columnLabel: String): T? =
        runCatching {
            this.any(columnLabel) as? T
        }.getOrNull()

    inline fun <reified T : Any> T.asMap(): Map<String, Any?> {
        val props = T::class.memberProperties.associateBy { it.name }
        return props.keys.associateWith { props[it]?.get(this) }
    }

    suspend fun <A> HikariDataSource.transaction(operation: suspend (TransactionalSession) -> A): A =
        sessionOf(this, returnGeneratedKey = true).use { session ->
            session.suspendTransaction { tx ->
                operation(tx)
            }
        }

    suspend fun <A> HikariDataSource.useSession(operation: suspend (Session) -> A): A =
        sessionOf(this, returnGeneratedKey = true).use { session ->
            operation(session)
        }

    private suspend fun <A : AutoCloseable, R> using(
        closeable: A?,
        f: (A) -> R,
    ): R = LoanPattern.using(closeable, f)

    private suspend inline fun <A> Session.suspendTransaction(operation: suspend (TransactionalSession) -> A): A {
        var shouldCommit = true
        try {
            connection.begin()
            transactional = true
            val tx = TransactionalSession(connection, returnGeneratedKeys, autoGeneratedKeys, strict)
            return operation.invoke(tx)
        } catch (e: Exception) {
            shouldCommit = false
            connection.rollback()
            throw e
        } finally {
            if (shouldCommit) {
                connection.commit()
            }
            transactional = false
        }
    }
}
